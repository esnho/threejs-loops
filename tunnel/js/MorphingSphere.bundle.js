(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{39:function(n,e){n.exports='#define GLSLIFY 1\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/stegu/webgl-noise\n//\n\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec3 P, vec3 rep)\n{\n  vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n  vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\nuniform float time;\n\nvarying vec2 vUv;\nvarying float noise;\nvarying float lowNoise;\n\nfloat turbulence( vec3 p ) {\n    float w = 100.0;\n    float t = -.5;\n    for (float f = 1.0 ; f <= 10.0 ; f++ ){\n        float power = pow( 2.0, f );\n        t += abs( pnoise( vec3( power * p ), vec3( 10.0, 10.0, 10.0 ) ) / power );\n    }\n    return t;\n}\n\nvoid main() {\n\n    vUv = uv;\n\n    // get a turbulent 3d noise using the normal, normal to high freq\n    noise = turbulence( .5 * normal );\n    // get a 3d noise using the position, low frequency\n    lowNoise = 2.0 * pnoise( 0.5 * position + time, vec3( 10.0 ) );\n    // compose both noises\n    float displacement = abs(noise + lowNoise);\n    \n    // move the position along the normal and transform it\n    vec3 newPosition = position + (normal * ((displacement * 2.0) - 1.0));\n    noise = displacement;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );\n\n}'},4:function(n,e,o){"use strict";o.r(e),o.d(e,"default",function(){return a});var t=o(29),g=o(39),c=o.n(g),i=o(40),r=o.n(i);function v(n,e){for(var o=0;o<e.length;o++){var t=e[o];t.enumerable=t.enumerable||!1,t.configurable=!0,"value"in t&&(t.writable=!0),Object.defineProperty(n,t.key,t)}}var a=function(){function n(e){var o=e.scene,g=e.onLoad;!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n);var i=new t.Color;i.setHSL(.62,.9,.2),o.renderer.setClearColor(i);var v=o.camera.aspect;o.camera=new t.OrthographicCamera(10*v/-2,10*v/2,5,-5,1,150),o.camera.position.copy(new t.Vector3(0,50,50)),o.camera.lookAt(new t.Vector3(0,0,0)),this.root=new t.Group,this.material=new t.ShaderMaterial({uniforms:{time:{type:"f",value:0}},vertexShader:c.a,fragmentShader:r.a});var a=new t.Mesh(new t.IcosahedronGeometry(3,5),this.material);this.root.add(a),this.inspiredBy=document.createElement("div"),this.inspiredBy.innerHTML="Edit from: https://www.clicktorelease.com/blog/vertex-displacement-noise-3d-webgl-glsl-three-js.html",this.inspiredBy.style.position="absolute",this.inspiredBy.style.bottom=3,this.inspiredBy.style.right=3,this.inspiredBy.style.color="darkcyan",document.body.appendChild(this.inspiredBy),g&&g()}var e,o,g;return e=n,(o=[{key:"update",value:function(n){this.root.rotateY(1e-4),this.root.rotateX(6e-4),this.material.uniforms.time.value=.1*n}},{key:"onRemove",value:function(){document.body.removeChild(this.inspiredBy)}}])&&v(e.prototype,o),g&&v(e,g),n}()},40:function(n,e){n.exports='#define GLSLIFY 1\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/stegu/webgl-noise\n//\n\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec3 P, vec3 rep)\n{\n  vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n  vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\nvarying vec2 vUv;\nvarying float noise;\nvarying float lowNoise;\n\nvoid main() {\n    vec3 ColorTop = vec3(1.,0.55,0);\n    vec3 ColorMid = vec3(0.226,0.000,0.615);\n    vec3 ColorBot = vec3(0,0,0);\n    float Middle = 0.85;\n\n    float k = 1.0- pow(noise, 1.4);\n    float kstep = step(k, Middle);\n    \n    vec3 color = mix(\n        ColorTop,\n        ColorMid,\n        k / Middle\n    ) * kstep;\n\n    color += mix(\n        ColorMid,\n        ColorBot,\n        (k - Middle) / (1.0 - Middle)\n    ) * (1.0 - kstep);\n\n    //color = vec3( pnoise( vec3( vUv.xy * 10.0, 1 ), vec3( 10.0, 10.0, 10.0 ) ) );\n    //color = vec3(abs(noise*1.0));\n    gl_FragColor = vec4( color, 1.0 );\n\n}'}}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvU2hhZGVycy9ub2lzZS1kaXNwbGFjZW1lbnQudmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvTG9vcHMvTW9ycGhpbmdTcGhlcmUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL1NoYWRlcnMvbm9pc2Utdmlldy11di5mcmFnIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJNb3JwaGluZ1NwaGVyZSIsIl9yZWYiLCJzY2VuZSIsIm9uTG9hZCIsIl9jbGFzc0NhbGxDaGVjayIsInRoaXMiLCJjbGVhckNvbG9yIiwiQ29sb3IiLCJzZXRIU0wiLCJyZW5kZXJlciIsInNldENsZWFyQ29sb3IiLCJhc3BlY3QiLCJjYW1lcmEiLCJPcnRob2dyYXBoaWNDYW1lcmEiLCJmcnVzdHVtU2l6ZSIsInBvc2l0aW9uIiwiY29weSIsIlZlY3RvcjMiLCJsb29rQXQiLCJyb290IiwiR3JvdXAiLCJtYXRlcmlhbCIsIlNoYWRlck1hdGVyaWFsIiwidW5pZm9ybXMiLCJ0aW1lIiwidHlwZSIsInZhbHVlIiwidmVydGV4U2hhZGVyIiwibm9pc2VEaXNwIiwiZnJhZ21lbnRTaGFkZXIiLCJiYXNpY3V2dmllcyIsIm1lc2giLCJNZXNoIiwiSWNvc2FoZWRyb25HZW9tZXRyeSIsImFkZCIsImluc3BpcmVkQnkiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJpbm5lckhUTUwiLCJzdHlsZSIsImJvdHRvbSIsInJpZ2h0IiwiY29sb3IiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJ0aW1lRWxhcHNlZCIsInJvdGF0ZVkiLCJyb3RhdGVYIiwicmVtb3ZlQ2hpbGQiXSwibWFwcGluZ3MiOiIwRUFBQUEsRUFBQUMsUUFBQSxrMU5DWXFCQyxhQUNuQixTQUFBQSxFQUFBQyxHQUE2QixJQUFoQkMsRUFBZ0JELEVBQWhCQyxNQUFPQyxFQUFTRixFQUFURSxvR0FBU0MsQ0FBQUMsS0FBQUwsR0FDM0IsSUFBTU0sRUFBYSxJQUFJQyxRQUN2QkQsRUFBV0UsT0FBTyxJQUFNLEdBQUssSUFDN0JOLEVBQU1PLFNBQVNDLGNBQWNKLEdBRTdCLElBQ01LLEVBQVNULEVBQU1VLE9BQU9ELE9BRTVCVCxFQUFNVSxPQUFTLElBQUlDLHFCQUhDLEdBSUZGLEdBQVcsRUFKVCxHQUtGQSxFQUFTLEVBQ3ZCRyxHQUNBQSxFQUNBLEVBQ0EsS0FFSlosRUFBTVUsT0FBT0csU0FBU0MsS0FBSyxJQUFJQyxVQUFRLEVBQUcsR0FBSSxLQUM5Q2YsRUFBTVUsT0FBT00sT0FBTyxJQUFJRCxVQUFRLEVBQUcsRUFBRyxJQUV0Q1osS0FBS2MsS0FBTyxJQUFJQyxRQUVoQmYsS0FBS2dCLFNBQVcsSUFBSUMsaUJBQWdCLENBQ2xDQyxTQUFVLENBQ1JDLEtBQU0sQ0FDRkMsS0FBTSxJQUNOQyxNQUFPLElBR2JDLGFBQWNDLElBQ2RDLGVBQWdCQyxNQUdsQixJQUFNQyxFQUFPLElBQUlDLE9BQ2IsSUFBSUMsc0JBQXFCLEVBQUcsR0FDNUI1QixLQUFLZ0IsVUFHVGhCLEtBQUtjLEtBQUtlLElBQUtILEdBRWYxQixLQUFLOEIsV0FBYUMsU0FBU0MsY0FBYyxPQUN6Q2hDLEtBQUs4QixXQUFXRyxVQUFZLHVHQUM1QmpDLEtBQUs4QixXQUFXSSxNQUFNeEIsU0FBVyxXQUNqQ1YsS0FBSzhCLFdBQVdJLE1BQU1DLE9BQVMsRUFDL0JuQyxLQUFLOEIsV0FBV0ksTUFBTUUsTUFBUSxFQUM5QnBDLEtBQUs4QixXQUFXSSxNQUFNRyxNQUFRLFdBRTlCTixTQUFTTyxLQUFLQyxZQUFZdkMsS0FBSzhCLFlBRTNCaEMsR0FBUUEsMERBR1AwQyxHQUNMeEMsS0FBS2MsS0FBSzJCLFFBQVEsTUFDbEJ6QyxLQUFLYyxLQUFLNEIsUUFBUSxNQUNsQjFDLEtBQUtnQixTQUFTRSxTQUFkLEtBQWlDRyxNQUFzQixHQUFkbUIscUNBSXpDVCxTQUFTTyxLQUFLSyxZQUFZM0MsS0FBSzhCLG1FQ3ZFbkNyQyxFQUFBQyxRQUFBIiwiZmlsZSI6Ii4vanMvTW9ycGhpbmdTcGhlcmUuYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIiNkZWZpbmUgR0xTTElGWSAxXFxuLy9cXG4vLyBHTFNMIHRleHR1cmVsZXNzIGNsYXNzaWMgM0Qgbm9pc2UgXFxcImNub2lzZVxcXCIsXFxuLy8gd2l0aCBhbiBSU0wtc3R5bGUgcGVyaW9kaWMgdmFyaWFudCBcXFwicG5vaXNlXFxcIi5cXG4vLyBBdXRob3I6ICBTdGVmYW4gR3VzdGF2c29uIChzdGVmYW4uZ3VzdGF2c29uQGxpdS5zZSlcXG4vLyBWZXJzaW9uOiAyMDExLTEwLTExXFxuLy9cXG4vLyBNYW55IHRoYW5rcyB0byBJYW4gTWNFd2FuIG9mIEFzaGltYSBBcnRzIGZvciB0aGVcXG4vLyBpZGVhcyBmb3IgcGVybXV0YXRpb24gYW5kIGdyYWRpZW50IHNlbGVjdGlvbi5cXG4vL1xcbi8vIENvcHlyaWdodCAoYykgMjAxMSBTdGVmYW4gR3VzdGF2c29uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZS5cXG4vLyBodHRwczovL2dpdGh1Yi5jb20vc3RlZ3Uvd2ViZ2wtbm9pc2VcXG4vL1xcblxcbnZlYzMgbW9kMjg5KHZlYzMgeClcXG57XFxuICByZXR1cm4geCAtIGZsb29yKHggKiAoMS4wIC8gMjg5LjApKSAqIDI4OS4wO1xcbn1cXG5cXG52ZWM0IG1vZDI4OSh2ZWM0IHgpXFxue1xcbiAgcmV0dXJuIHggLSBmbG9vcih4ICogKDEuMCAvIDI4OS4wKSkgKiAyODkuMDtcXG59XFxuXFxudmVjNCBwZXJtdXRlKHZlYzQgeClcXG57XFxuICByZXR1cm4gbW9kMjg5KCgoeCozNC4wKSsxLjApKngpO1xcbn1cXG5cXG52ZWM0IHRheWxvckludlNxcnQodmVjNCByKVxcbntcXG4gIHJldHVybiAxLjc5Mjg0MjkxNDAwMTU5IC0gMC44NTM3MzQ3MjA5NTMxNCAqIHI7XFxufVxcblxcbnZlYzMgZmFkZSh2ZWMzIHQpIHtcXG4gIHJldHVybiB0KnQqdCoodCoodCo2LjAtMTUuMCkrMTAuMCk7XFxufVxcblxcbi8vIENsYXNzaWMgUGVybGluIG5vaXNlXFxuZmxvYXQgY25vaXNlKHZlYzMgUClcXG57XFxuICB2ZWMzIFBpMCA9IGZsb29yKFApOyAvLyBJbnRlZ2VyIHBhcnQgZm9yIGluZGV4aW5nXFxuICB2ZWMzIFBpMSA9IFBpMCArIHZlYzMoMS4wKTsgLy8gSW50ZWdlciBwYXJ0ICsgMVxcbiAgUGkwID0gbW9kMjg5KFBpMCk7XFxuICBQaTEgPSBtb2QyODkoUGkxKTtcXG4gIHZlYzMgUGYwID0gZnJhY3QoUCk7IC8vIEZyYWN0aW9uYWwgcGFydCBmb3IgaW50ZXJwb2xhdGlvblxcbiAgdmVjMyBQZjEgPSBQZjAgLSB2ZWMzKDEuMCk7IC8vIEZyYWN0aW9uYWwgcGFydCAtIDEuMFxcbiAgdmVjNCBpeCA9IHZlYzQoUGkwLngsIFBpMS54LCBQaTAueCwgUGkxLngpO1xcbiAgdmVjNCBpeSA9IHZlYzQoUGkwLnl5LCBQaTEueXkpO1xcbiAgdmVjNCBpejAgPSBQaTAuenp6ejtcXG4gIHZlYzQgaXoxID0gUGkxLnp6eno7XFxuXFxuICB2ZWM0IGl4eSA9IHBlcm11dGUocGVybXV0ZShpeCkgKyBpeSk7XFxuICB2ZWM0IGl4eTAgPSBwZXJtdXRlKGl4eSArIGl6MCk7XFxuICB2ZWM0IGl4eTEgPSBwZXJtdXRlKGl4eSArIGl6MSk7XFxuXFxuICB2ZWM0IGd4MCA9IGl4eTAgKiAoMS4wIC8gNy4wKTtcXG4gIHZlYzQgZ3kwID0gZnJhY3QoZmxvb3IoZ3gwKSAqICgxLjAgLyA3LjApKSAtIDAuNTtcXG4gIGd4MCA9IGZyYWN0KGd4MCk7XFxuICB2ZWM0IGd6MCA9IHZlYzQoMC41KSAtIGFicyhneDApIC0gYWJzKGd5MCk7XFxuICB2ZWM0IHN6MCA9IHN0ZXAoZ3owLCB2ZWM0KDAuMCkpO1xcbiAgZ3gwIC09IHN6MCAqIChzdGVwKDAuMCwgZ3gwKSAtIDAuNSk7XFxuICBneTAgLT0gc3owICogKHN0ZXAoMC4wLCBneTApIC0gMC41KTtcXG5cXG4gIHZlYzQgZ3gxID0gaXh5MSAqICgxLjAgLyA3LjApO1xcbiAgdmVjNCBneTEgPSBmcmFjdChmbG9vcihneDEpICogKDEuMCAvIDcuMCkpIC0gMC41O1xcbiAgZ3gxID0gZnJhY3QoZ3gxKTtcXG4gIHZlYzQgZ3oxID0gdmVjNCgwLjUpIC0gYWJzKGd4MSkgLSBhYnMoZ3kxKTtcXG4gIHZlYzQgc3oxID0gc3RlcChnejEsIHZlYzQoMC4wKSk7XFxuICBneDEgLT0gc3oxICogKHN0ZXAoMC4wLCBneDEpIC0gMC41KTtcXG4gIGd5MSAtPSBzejEgKiAoc3RlcCgwLjAsIGd5MSkgLSAwLjUpO1xcblxcbiAgdmVjMyBnMDAwID0gdmVjMyhneDAueCxneTAueCxnejAueCk7XFxuICB2ZWMzIGcxMDAgPSB2ZWMzKGd4MC55LGd5MC55LGd6MC55KTtcXG4gIHZlYzMgZzAxMCA9IHZlYzMoZ3gwLnosZ3kwLnosZ3owLnopO1xcbiAgdmVjMyBnMTEwID0gdmVjMyhneDAudyxneTAudyxnejAudyk7XFxuICB2ZWMzIGcwMDEgPSB2ZWMzKGd4MS54LGd5MS54LGd6MS54KTtcXG4gIHZlYzMgZzEwMSA9IHZlYzMoZ3gxLnksZ3kxLnksZ3oxLnkpO1xcbiAgdmVjMyBnMDExID0gdmVjMyhneDEueixneTEueixnejEueik7XFxuICB2ZWMzIGcxMTEgPSB2ZWMzKGd4MS53LGd5MS53LGd6MS53KTtcXG5cXG4gIHZlYzQgbm9ybTAgPSB0YXlsb3JJbnZTcXJ0KHZlYzQoZG90KGcwMDAsIGcwMDApLCBkb3QoZzAxMCwgZzAxMCksIGRvdChnMTAwLCBnMTAwKSwgZG90KGcxMTAsIGcxMTApKSk7XFxuICBnMDAwICo9IG5vcm0wLng7XFxuICBnMDEwICo9IG5vcm0wLnk7XFxuICBnMTAwICo9IG5vcm0wLno7XFxuICBnMTEwICo9IG5vcm0wLnc7XFxuICB2ZWM0IG5vcm0xID0gdGF5bG9ySW52U3FydCh2ZWM0KGRvdChnMDAxLCBnMDAxKSwgZG90KGcwMTEsIGcwMTEpLCBkb3QoZzEwMSwgZzEwMSksIGRvdChnMTExLCBnMTExKSkpO1xcbiAgZzAwMSAqPSBub3JtMS54O1xcbiAgZzAxMSAqPSBub3JtMS55O1xcbiAgZzEwMSAqPSBub3JtMS56O1xcbiAgZzExMSAqPSBub3JtMS53O1xcblxcbiAgZmxvYXQgbjAwMCA9IGRvdChnMDAwLCBQZjApO1xcbiAgZmxvYXQgbjEwMCA9IGRvdChnMTAwLCB2ZWMzKFBmMS54LCBQZjAueXopKTtcXG4gIGZsb2F0IG4wMTAgPSBkb3QoZzAxMCwgdmVjMyhQZjAueCwgUGYxLnksIFBmMC56KSk7XFxuICBmbG9hdCBuMTEwID0gZG90KGcxMTAsIHZlYzMoUGYxLnh5LCBQZjAueikpO1xcbiAgZmxvYXQgbjAwMSA9IGRvdChnMDAxLCB2ZWMzKFBmMC54eSwgUGYxLnopKTtcXG4gIGZsb2F0IG4xMDEgPSBkb3QoZzEwMSwgdmVjMyhQZjEueCwgUGYwLnksIFBmMS56KSk7XFxuICBmbG9hdCBuMDExID0gZG90KGcwMTEsIHZlYzMoUGYwLngsIFBmMS55eikpO1xcbiAgZmxvYXQgbjExMSA9IGRvdChnMTExLCBQZjEpO1xcblxcbiAgdmVjMyBmYWRlX3h5eiA9IGZhZGUoUGYwKTtcXG4gIHZlYzQgbl96ID0gbWl4KHZlYzQobjAwMCwgbjEwMCwgbjAxMCwgbjExMCksIHZlYzQobjAwMSwgbjEwMSwgbjAxMSwgbjExMSksIGZhZGVfeHl6LnopO1xcbiAgdmVjMiBuX3l6ID0gbWl4KG5fei54eSwgbl96Lnp3LCBmYWRlX3h5ei55KTtcXG4gIGZsb2F0IG5feHl6ID0gbWl4KG5feXoueCwgbl95ei55LCBmYWRlX3h5ei54KTsgXFxuICByZXR1cm4gMi4yICogbl94eXo7XFxufVxcblxcbi8vIENsYXNzaWMgUGVybGluIG5vaXNlLCBwZXJpb2RpYyB2YXJpYW50XFxuZmxvYXQgcG5vaXNlKHZlYzMgUCwgdmVjMyByZXApXFxue1xcbiAgdmVjMyBQaTAgPSBtb2QoZmxvb3IoUCksIHJlcCk7IC8vIEludGVnZXIgcGFydCwgbW9kdWxvIHBlcmlvZFxcbiAgdmVjMyBQaTEgPSBtb2QoUGkwICsgdmVjMygxLjApLCByZXApOyAvLyBJbnRlZ2VyIHBhcnQgKyAxLCBtb2QgcGVyaW9kXFxuICBQaTAgPSBtb2QyODkoUGkwKTtcXG4gIFBpMSA9IG1vZDI4OShQaTEpO1xcbiAgdmVjMyBQZjAgPSBmcmFjdChQKTsgLy8gRnJhY3Rpb25hbCBwYXJ0IGZvciBpbnRlcnBvbGF0aW9uXFxuICB2ZWMzIFBmMSA9IFBmMCAtIHZlYzMoMS4wKTsgLy8gRnJhY3Rpb25hbCBwYXJ0IC0gMS4wXFxuICB2ZWM0IGl4ID0gdmVjNChQaTAueCwgUGkxLngsIFBpMC54LCBQaTEueCk7XFxuICB2ZWM0IGl5ID0gdmVjNChQaTAueXksIFBpMS55eSk7XFxuICB2ZWM0IGl6MCA9IFBpMC56enp6O1xcbiAgdmVjNCBpejEgPSBQaTEuenp6ejtcXG5cXG4gIHZlYzQgaXh5ID0gcGVybXV0ZShwZXJtdXRlKGl4KSArIGl5KTtcXG4gIHZlYzQgaXh5MCA9IHBlcm11dGUoaXh5ICsgaXowKTtcXG4gIHZlYzQgaXh5MSA9IHBlcm11dGUoaXh5ICsgaXoxKTtcXG5cXG4gIHZlYzQgZ3gwID0gaXh5MCAqICgxLjAgLyA3LjApO1xcbiAgdmVjNCBneTAgPSBmcmFjdChmbG9vcihneDApICogKDEuMCAvIDcuMCkpIC0gMC41O1xcbiAgZ3gwID0gZnJhY3QoZ3gwKTtcXG4gIHZlYzQgZ3owID0gdmVjNCgwLjUpIC0gYWJzKGd4MCkgLSBhYnMoZ3kwKTtcXG4gIHZlYzQgc3owID0gc3RlcChnejAsIHZlYzQoMC4wKSk7XFxuICBneDAgLT0gc3owICogKHN0ZXAoMC4wLCBneDApIC0gMC41KTtcXG4gIGd5MCAtPSBzejAgKiAoc3RlcCgwLjAsIGd5MCkgLSAwLjUpO1xcblxcbiAgdmVjNCBneDEgPSBpeHkxICogKDEuMCAvIDcuMCk7XFxuICB2ZWM0IGd5MSA9IGZyYWN0KGZsb29yKGd4MSkgKiAoMS4wIC8gNy4wKSkgLSAwLjU7XFxuICBneDEgPSBmcmFjdChneDEpO1xcbiAgdmVjNCBnejEgPSB2ZWM0KDAuNSkgLSBhYnMoZ3gxKSAtIGFicyhneTEpO1xcbiAgdmVjNCBzejEgPSBzdGVwKGd6MSwgdmVjNCgwLjApKTtcXG4gIGd4MSAtPSBzejEgKiAoc3RlcCgwLjAsIGd4MSkgLSAwLjUpO1xcbiAgZ3kxIC09IHN6MSAqIChzdGVwKDAuMCwgZ3kxKSAtIDAuNSk7XFxuXFxuICB2ZWMzIGcwMDAgPSB2ZWMzKGd4MC54LGd5MC54LGd6MC54KTtcXG4gIHZlYzMgZzEwMCA9IHZlYzMoZ3gwLnksZ3kwLnksZ3owLnkpO1xcbiAgdmVjMyBnMDEwID0gdmVjMyhneDAueixneTAueixnejAueik7XFxuICB2ZWMzIGcxMTAgPSB2ZWMzKGd4MC53LGd5MC53LGd6MC53KTtcXG4gIHZlYzMgZzAwMSA9IHZlYzMoZ3gxLngsZ3kxLngsZ3oxLngpO1xcbiAgdmVjMyBnMTAxID0gdmVjMyhneDEueSxneTEueSxnejEueSk7XFxuICB2ZWMzIGcwMTEgPSB2ZWMzKGd4MS56LGd5MS56LGd6MS56KTtcXG4gIHZlYzMgZzExMSA9IHZlYzMoZ3gxLncsZ3kxLncsZ3oxLncpO1xcblxcbiAgdmVjNCBub3JtMCA9IHRheWxvckludlNxcnQodmVjNChkb3QoZzAwMCwgZzAwMCksIGRvdChnMDEwLCBnMDEwKSwgZG90KGcxMDAsIGcxMDApLCBkb3QoZzExMCwgZzExMCkpKTtcXG4gIGcwMDAgKj0gbm9ybTAueDtcXG4gIGcwMTAgKj0gbm9ybTAueTtcXG4gIGcxMDAgKj0gbm9ybTAuejtcXG4gIGcxMTAgKj0gbm9ybTAudztcXG4gIHZlYzQgbm9ybTEgPSB0YXlsb3JJbnZTcXJ0KHZlYzQoZG90KGcwMDEsIGcwMDEpLCBkb3QoZzAxMSwgZzAxMSksIGRvdChnMTAxLCBnMTAxKSwgZG90KGcxMTEsIGcxMTEpKSk7XFxuICBnMDAxICo9IG5vcm0xLng7XFxuICBnMDExICo9IG5vcm0xLnk7XFxuICBnMTAxICo9IG5vcm0xLno7XFxuICBnMTExICo9IG5vcm0xLnc7XFxuXFxuICBmbG9hdCBuMDAwID0gZG90KGcwMDAsIFBmMCk7XFxuICBmbG9hdCBuMTAwID0gZG90KGcxMDAsIHZlYzMoUGYxLngsIFBmMC55eikpO1xcbiAgZmxvYXQgbjAxMCA9IGRvdChnMDEwLCB2ZWMzKFBmMC54LCBQZjEueSwgUGYwLnopKTtcXG4gIGZsb2F0IG4xMTAgPSBkb3QoZzExMCwgdmVjMyhQZjEueHksIFBmMC56KSk7XFxuICBmbG9hdCBuMDAxID0gZG90KGcwMDEsIHZlYzMoUGYwLnh5LCBQZjEueikpO1xcbiAgZmxvYXQgbjEwMSA9IGRvdChnMTAxLCB2ZWMzKFBmMS54LCBQZjAueSwgUGYxLnopKTtcXG4gIGZsb2F0IG4wMTEgPSBkb3QoZzAxMSwgdmVjMyhQZjAueCwgUGYxLnl6KSk7XFxuICBmbG9hdCBuMTExID0gZG90KGcxMTEsIFBmMSk7XFxuXFxuICB2ZWMzIGZhZGVfeHl6ID0gZmFkZShQZjApO1xcbiAgdmVjNCBuX3ogPSBtaXgodmVjNChuMDAwLCBuMTAwLCBuMDEwLCBuMTEwKSwgdmVjNChuMDAxLCBuMTAxLCBuMDExLCBuMTExKSwgZmFkZV94eXoueik7XFxuICB2ZWMyIG5feXogPSBtaXgobl96Lnh5LCBuX3ouencsIGZhZGVfeHl6LnkpO1xcbiAgZmxvYXQgbl94eXogPSBtaXgobl95ei54LCBuX3l6LnksIGZhZGVfeHl6LngpOyBcXG4gIHJldHVybiAyLjIgKiBuX3h5ejtcXG59XFxuXFxudW5pZm9ybSBmbG9hdCB0aW1lO1xcblxcbnZhcnlpbmcgdmVjMiB2VXY7XFxudmFyeWluZyBmbG9hdCBub2lzZTtcXG52YXJ5aW5nIGZsb2F0IGxvd05vaXNlO1xcblxcbmZsb2F0IHR1cmJ1bGVuY2UoIHZlYzMgcCApIHtcXG4gICAgZmxvYXQgdyA9IDEwMC4wO1xcbiAgICBmbG9hdCB0ID0gLS41O1xcbiAgICBmb3IgKGZsb2F0IGYgPSAxLjAgOyBmIDw9IDEwLjAgOyBmKysgKXtcXG4gICAgICAgIGZsb2F0IHBvd2VyID0gcG93KCAyLjAsIGYgKTtcXG4gICAgICAgIHQgKz0gYWJzKCBwbm9pc2UoIHZlYzMoIHBvd2VyICogcCApLCB2ZWMzKCAxMC4wLCAxMC4wLCAxMC4wICkgKSAvIHBvd2VyICk7XFxuICAgIH1cXG4gICAgcmV0dXJuIHQ7XFxufVxcblxcbnZvaWQgbWFpbigpIHtcXG5cXG4gICAgdlV2ID0gdXY7XFxuXFxuICAgIC8vIGdldCBhIHR1cmJ1bGVudCAzZCBub2lzZSB1c2luZyB0aGUgbm9ybWFsLCBub3JtYWwgdG8gaGlnaCBmcmVxXFxuICAgIG5vaXNlID0gdHVyYnVsZW5jZSggLjUgKiBub3JtYWwgKTtcXG4gICAgLy8gZ2V0IGEgM2Qgbm9pc2UgdXNpbmcgdGhlIHBvc2l0aW9uLCBsb3cgZnJlcXVlbmN5XFxuICAgIGxvd05vaXNlID0gMi4wICogcG5vaXNlKCAwLjUgKiBwb3NpdGlvbiArIHRpbWUsIHZlYzMoIDEwLjAgKSApO1xcbiAgICAvLyBjb21wb3NlIGJvdGggbm9pc2VzXFxuICAgIGZsb2F0IGRpc3BsYWNlbWVudCA9IGFicyhub2lzZSArIGxvd05vaXNlKTtcXG4gICAgXFxuICAgIC8vIG1vdmUgdGhlIHBvc2l0aW9uIGFsb25nIHRoZSBub3JtYWwgYW5kIHRyYW5zZm9ybSBpdFxcbiAgICB2ZWMzIG5ld1Bvc2l0aW9uID0gcG9zaXRpb24gKyAobm9ybWFsICogKChkaXNwbGFjZW1lbnQgKiAyLjApIC0gMS4wKSk7XFxuICAgIG5vaXNlID0gZGlzcGxhY2VtZW50O1xcbiAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBuZXdQb3NpdGlvbiwgMS4wICk7XFxuXFxufVwiIiwiaW1wb3J0IHtcbiAgVmVjdG9yMyxcbiAgQ29sb3IsXG4gIE1lc2gsXG4gIEdyb3VwLFxuICBPcnRob2dyYXBoaWNDYW1lcmEsXG4gIFNoYWRlck1hdGVyaWFsLFxuICBJY29zYWhlZHJvbkdlb21ldHJ5XG59IGZyb20gJ3RocmVlJztcbmltcG9ydCBub2lzZURpc3AgZnJvbSAnLi4vU2hhZGVycy9ub2lzZS1kaXNwbGFjZW1lbnQudmVydCc7XG5pbXBvcnQgYmFzaWN1dnZpZXMgZnJvbSAnLi4vU2hhZGVycy9ub2lzZS12aWV3LXV2LmZyYWcnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb3JwaGluZ1NwaGVyZSB7XG4gIGNvbnN0cnVjdG9yKHtzY2VuZSwgb25Mb2FkfSkge1xuICAgIGNvbnN0IGNsZWFyQ29sb3IgPSBuZXcgQ29sb3IoKTtcbiAgICBjbGVhckNvbG9yLnNldEhTTCgwLjYyLCAwLjksIDAuMik7XG4gICAgc2NlbmUucmVuZGVyZXIuc2V0Q2xlYXJDb2xvcihjbGVhckNvbG9yKTtcblxuICAgIGNvbnN0IGZydXN0dW1TaXplID0gMTA7XG4gICAgY29uc3QgYXNwZWN0ID0gc2NlbmUuY2FtZXJhLmFzcGVjdDtcblxuICAgIHNjZW5lLmNhbWVyYSA9IG5ldyBPcnRob2dyYXBoaWNDYW1lcmEoXG4gICAgICAgIGZydXN0dW1TaXplICogYXNwZWN0IC8gLSAyLFxuICAgICAgICBmcnVzdHVtU2l6ZSAqIGFzcGVjdCAvIDIsXG4gICAgICAgIGZydXN0dW1TaXplIC8gMixcbiAgICAgICAgZnJ1c3R1bVNpemUgLyAtIDIsXG4gICAgICAgIDEsXG4gICAgICAgIDE1MFxuICAgICk7XG4gICAgc2NlbmUuY2FtZXJhLnBvc2l0aW9uLmNvcHkobmV3IFZlY3RvcjMoMCwgNTAsIDUwKSk7XG4gICAgc2NlbmUuY2FtZXJhLmxvb2tBdChuZXcgVmVjdG9yMygwLCAwLCAwKSk7XG5cbiAgICB0aGlzLnJvb3QgPSBuZXcgR3JvdXAoKTtcblxuICAgIHRoaXMubWF0ZXJpYWwgPSBuZXcgU2hhZGVyTWF0ZXJpYWwoIHtcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIHRpbWU6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZlwiLCBcbiAgICAgICAgICAgIHZhbHVlOiAwLjAgXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IG5vaXNlRGlzcCxcbiAgICAgIGZyYWdtZW50U2hhZGVyOiBiYXNpY3V2dmllc1xuICAgIH0pO1xuXG4gICAgY29uc3QgbWVzaCA9IG5ldyBNZXNoKCBcbiAgICAgICAgbmV3IEljb3NhaGVkcm9uR2VvbWV0cnkoIDMsIDUgKSwgXG4gICAgICAgIHRoaXMubWF0ZXJpYWwgXG4gICAgKTtcbiAgICBcbiAgICB0aGlzLnJvb3QuYWRkKCBtZXNoICk7XG5cbiAgICB0aGlzLmluc3BpcmVkQnkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmluc3BpcmVkQnkuaW5uZXJIVE1MID0gJ0VkaXQgZnJvbTogaHR0cHM6Ly93d3cuY2xpY2t0b3JlbGVhc2UuY29tL2Jsb2cvdmVydGV4LWRpc3BsYWNlbWVudC1ub2lzZS0zZC13ZWJnbC1nbHNsLXRocmVlLWpzLmh0bWwnO1xuICAgIHRoaXMuaW5zcGlyZWRCeS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgdGhpcy5pbnNwaXJlZEJ5LnN0eWxlLmJvdHRvbSA9IDM7XG4gICAgdGhpcy5pbnNwaXJlZEJ5LnN0eWxlLnJpZ2h0ID0gMztcbiAgICB0aGlzLmluc3BpcmVkQnkuc3R5bGUuY29sb3IgPSAnZGFya2N5YW4nO1xuXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmluc3BpcmVkQnkpO1xuXG4gICAgaWYgKG9uTG9hZCkgb25Mb2FkKCk7XG4gIH1cblxuICB1cGRhdGUodGltZUVsYXBzZWQpIHtcbiAgICB0aGlzLnJvb3Qucm90YXRlWSgwLjAwMDEpO1xuICAgIHRoaXMucm9vdC5yb3RhdGVYKDAuMDAwNik7XG4gICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtc1sgJ3RpbWUnIF0udmFsdWUgPSB0aW1lRWxhcHNlZCAqIDAuMTtcbiAgfVxuXG4gIG9uUmVtb3ZlKCkge1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGhpcy5pbnNwaXJlZEJ5KTtcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBcIiNkZWZpbmUgR0xTTElGWSAxXFxuLy9cXG4vLyBHTFNMIHRleHR1cmVsZXNzIGNsYXNzaWMgM0Qgbm9pc2UgXFxcImNub2lzZVxcXCIsXFxuLy8gd2l0aCBhbiBSU0wtc3R5bGUgcGVyaW9kaWMgdmFyaWFudCBcXFwicG5vaXNlXFxcIi5cXG4vLyBBdXRob3I6ICBTdGVmYW4gR3VzdGF2c29uIChzdGVmYW4uZ3VzdGF2c29uQGxpdS5zZSlcXG4vLyBWZXJzaW9uOiAyMDExLTEwLTExXFxuLy9cXG4vLyBNYW55IHRoYW5rcyB0byBJYW4gTWNFd2FuIG9mIEFzaGltYSBBcnRzIGZvciB0aGVcXG4vLyBpZGVhcyBmb3IgcGVybXV0YXRpb24gYW5kIGdyYWRpZW50IHNlbGVjdGlvbi5cXG4vL1xcbi8vIENvcHlyaWdodCAoYykgMjAxMSBTdGVmYW4gR3VzdGF2c29uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZS5cXG4vLyBodHRwczovL2dpdGh1Yi5jb20vc3RlZ3Uvd2ViZ2wtbm9pc2VcXG4vL1xcblxcbnZlYzMgbW9kMjg5KHZlYzMgeClcXG57XFxuICByZXR1cm4geCAtIGZsb29yKHggKiAoMS4wIC8gMjg5LjApKSAqIDI4OS4wO1xcbn1cXG5cXG52ZWM0IG1vZDI4OSh2ZWM0IHgpXFxue1xcbiAgcmV0dXJuIHggLSBmbG9vcih4ICogKDEuMCAvIDI4OS4wKSkgKiAyODkuMDtcXG59XFxuXFxudmVjNCBwZXJtdXRlKHZlYzQgeClcXG57XFxuICByZXR1cm4gbW9kMjg5KCgoeCozNC4wKSsxLjApKngpO1xcbn1cXG5cXG52ZWM0IHRheWxvckludlNxcnQodmVjNCByKVxcbntcXG4gIHJldHVybiAxLjc5Mjg0MjkxNDAwMTU5IC0gMC44NTM3MzQ3MjA5NTMxNCAqIHI7XFxufVxcblxcbnZlYzMgZmFkZSh2ZWMzIHQpIHtcXG4gIHJldHVybiB0KnQqdCoodCoodCo2LjAtMTUuMCkrMTAuMCk7XFxufVxcblxcbi8vIENsYXNzaWMgUGVybGluIG5vaXNlXFxuZmxvYXQgY25vaXNlKHZlYzMgUClcXG57XFxuICB2ZWMzIFBpMCA9IGZsb29yKFApOyAvLyBJbnRlZ2VyIHBhcnQgZm9yIGluZGV4aW5nXFxuICB2ZWMzIFBpMSA9IFBpMCArIHZlYzMoMS4wKTsgLy8gSW50ZWdlciBwYXJ0ICsgMVxcbiAgUGkwID0gbW9kMjg5KFBpMCk7XFxuICBQaTEgPSBtb2QyODkoUGkxKTtcXG4gIHZlYzMgUGYwID0gZnJhY3QoUCk7IC8vIEZyYWN0aW9uYWwgcGFydCBmb3IgaW50ZXJwb2xhdGlvblxcbiAgdmVjMyBQZjEgPSBQZjAgLSB2ZWMzKDEuMCk7IC8vIEZyYWN0aW9uYWwgcGFydCAtIDEuMFxcbiAgdmVjNCBpeCA9IHZlYzQoUGkwLngsIFBpMS54LCBQaTAueCwgUGkxLngpO1xcbiAgdmVjNCBpeSA9IHZlYzQoUGkwLnl5LCBQaTEueXkpO1xcbiAgdmVjNCBpejAgPSBQaTAuenp6ejtcXG4gIHZlYzQgaXoxID0gUGkxLnp6eno7XFxuXFxuICB2ZWM0IGl4eSA9IHBlcm11dGUocGVybXV0ZShpeCkgKyBpeSk7XFxuICB2ZWM0IGl4eTAgPSBwZXJtdXRlKGl4eSArIGl6MCk7XFxuICB2ZWM0IGl4eTEgPSBwZXJtdXRlKGl4eSArIGl6MSk7XFxuXFxuICB2ZWM0IGd4MCA9IGl4eTAgKiAoMS4wIC8gNy4wKTtcXG4gIHZlYzQgZ3kwID0gZnJhY3QoZmxvb3IoZ3gwKSAqICgxLjAgLyA3LjApKSAtIDAuNTtcXG4gIGd4MCA9IGZyYWN0KGd4MCk7XFxuICB2ZWM0IGd6MCA9IHZlYzQoMC41KSAtIGFicyhneDApIC0gYWJzKGd5MCk7XFxuICB2ZWM0IHN6MCA9IHN0ZXAoZ3owLCB2ZWM0KDAuMCkpO1xcbiAgZ3gwIC09IHN6MCAqIChzdGVwKDAuMCwgZ3gwKSAtIDAuNSk7XFxuICBneTAgLT0gc3owICogKHN0ZXAoMC4wLCBneTApIC0gMC41KTtcXG5cXG4gIHZlYzQgZ3gxID0gaXh5MSAqICgxLjAgLyA3LjApO1xcbiAgdmVjNCBneTEgPSBmcmFjdChmbG9vcihneDEpICogKDEuMCAvIDcuMCkpIC0gMC41O1xcbiAgZ3gxID0gZnJhY3QoZ3gxKTtcXG4gIHZlYzQgZ3oxID0gdmVjNCgwLjUpIC0gYWJzKGd4MSkgLSBhYnMoZ3kxKTtcXG4gIHZlYzQgc3oxID0gc3RlcChnejEsIHZlYzQoMC4wKSk7XFxuICBneDEgLT0gc3oxICogKHN0ZXAoMC4wLCBneDEpIC0gMC41KTtcXG4gIGd5MSAtPSBzejEgKiAoc3RlcCgwLjAsIGd5MSkgLSAwLjUpO1xcblxcbiAgdmVjMyBnMDAwID0gdmVjMyhneDAueCxneTAueCxnejAueCk7XFxuICB2ZWMzIGcxMDAgPSB2ZWMzKGd4MC55LGd5MC55LGd6MC55KTtcXG4gIHZlYzMgZzAxMCA9IHZlYzMoZ3gwLnosZ3kwLnosZ3owLnopO1xcbiAgdmVjMyBnMTEwID0gdmVjMyhneDAudyxneTAudyxnejAudyk7XFxuICB2ZWMzIGcwMDEgPSB2ZWMzKGd4MS54LGd5MS54LGd6MS54KTtcXG4gIHZlYzMgZzEwMSA9IHZlYzMoZ3gxLnksZ3kxLnksZ3oxLnkpO1xcbiAgdmVjMyBnMDExID0gdmVjMyhneDEueixneTEueixnejEueik7XFxuICB2ZWMzIGcxMTEgPSB2ZWMzKGd4MS53LGd5MS53LGd6MS53KTtcXG5cXG4gIHZlYzQgbm9ybTAgPSB0YXlsb3JJbnZTcXJ0KHZlYzQoZG90KGcwMDAsIGcwMDApLCBkb3QoZzAxMCwgZzAxMCksIGRvdChnMTAwLCBnMTAwKSwgZG90KGcxMTAsIGcxMTApKSk7XFxuICBnMDAwICo9IG5vcm0wLng7XFxuICBnMDEwICo9IG5vcm0wLnk7XFxuICBnMTAwICo9IG5vcm0wLno7XFxuICBnMTEwICo9IG5vcm0wLnc7XFxuICB2ZWM0IG5vcm0xID0gdGF5bG9ySW52U3FydCh2ZWM0KGRvdChnMDAxLCBnMDAxKSwgZG90KGcwMTEsIGcwMTEpLCBkb3QoZzEwMSwgZzEwMSksIGRvdChnMTExLCBnMTExKSkpO1xcbiAgZzAwMSAqPSBub3JtMS54O1xcbiAgZzAxMSAqPSBub3JtMS55O1xcbiAgZzEwMSAqPSBub3JtMS56O1xcbiAgZzExMSAqPSBub3JtMS53O1xcblxcbiAgZmxvYXQgbjAwMCA9IGRvdChnMDAwLCBQZjApO1xcbiAgZmxvYXQgbjEwMCA9IGRvdChnMTAwLCB2ZWMzKFBmMS54LCBQZjAueXopKTtcXG4gIGZsb2F0IG4wMTAgPSBkb3QoZzAxMCwgdmVjMyhQZjAueCwgUGYxLnksIFBmMC56KSk7XFxuICBmbG9hdCBuMTEwID0gZG90KGcxMTAsIHZlYzMoUGYxLnh5LCBQZjAueikpO1xcbiAgZmxvYXQgbjAwMSA9IGRvdChnMDAxLCB2ZWMzKFBmMC54eSwgUGYxLnopKTtcXG4gIGZsb2F0IG4xMDEgPSBkb3QoZzEwMSwgdmVjMyhQZjEueCwgUGYwLnksIFBmMS56KSk7XFxuICBmbG9hdCBuMDExID0gZG90KGcwMTEsIHZlYzMoUGYwLngsIFBmMS55eikpO1xcbiAgZmxvYXQgbjExMSA9IGRvdChnMTExLCBQZjEpO1xcblxcbiAgdmVjMyBmYWRlX3h5eiA9IGZhZGUoUGYwKTtcXG4gIHZlYzQgbl96ID0gbWl4KHZlYzQobjAwMCwgbjEwMCwgbjAxMCwgbjExMCksIHZlYzQobjAwMSwgbjEwMSwgbjAxMSwgbjExMSksIGZhZGVfeHl6LnopO1xcbiAgdmVjMiBuX3l6ID0gbWl4KG5fei54eSwgbl96Lnp3LCBmYWRlX3h5ei55KTtcXG4gIGZsb2F0IG5feHl6ID0gbWl4KG5feXoueCwgbl95ei55LCBmYWRlX3h5ei54KTsgXFxuICByZXR1cm4gMi4yICogbl94eXo7XFxufVxcblxcbi8vIENsYXNzaWMgUGVybGluIG5vaXNlLCBwZXJpb2RpYyB2YXJpYW50XFxuZmxvYXQgcG5vaXNlKHZlYzMgUCwgdmVjMyByZXApXFxue1xcbiAgdmVjMyBQaTAgPSBtb2QoZmxvb3IoUCksIHJlcCk7IC8vIEludGVnZXIgcGFydCwgbW9kdWxvIHBlcmlvZFxcbiAgdmVjMyBQaTEgPSBtb2QoUGkwICsgdmVjMygxLjApLCByZXApOyAvLyBJbnRlZ2VyIHBhcnQgKyAxLCBtb2QgcGVyaW9kXFxuICBQaTAgPSBtb2QyODkoUGkwKTtcXG4gIFBpMSA9IG1vZDI4OShQaTEpO1xcbiAgdmVjMyBQZjAgPSBmcmFjdChQKTsgLy8gRnJhY3Rpb25hbCBwYXJ0IGZvciBpbnRlcnBvbGF0aW9uXFxuICB2ZWMzIFBmMSA9IFBmMCAtIHZlYzMoMS4wKTsgLy8gRnJhY3Rpb25hbCBwYXJ0IC0gMS4wXFxuICB2ZWM0IGl4ID0gdmVjNChQaTAueCwgUGkxLngsIFBpMC54LCBQaTEueCk7XFxuICB2ZWM0IGl5ID0gdmVjNChQaTAueXksIFBpMS55eSk7XFxuICB2ZWM0IGl6MCA9IFBpMC56enp6O1xcbiAgdmVjNCBpejEgPSBQaTEuenp6ejtcXG5cXG4gIHZlYzQgaXh5ID0gcGVybXV0ZShwZXJtdXRlKGl4KSArIGl5KTtcXG4gIHZlYzQgaXh5MCA9IHBlcm11dGUoaXh5ICsgaXowKTtcXG4gIHZlYzQgaXh5MSA9IHBlcm11dGUoaXh5ICsgaXoxKTtcXG5cXG4gIHZlYzQgZ3gwID0gaXh5MCAqICgxLjAgLyA3LjApO1xcbiAgdmVjNCBneTAgPSBmcmFjdChmbG9vcihneDApICogKDEuMCAvIDcuMCkpIC0gMC41O1xcbiAgZ3gwID0gZnJhY3QoZ3gwKTtcXG4gIHZlYzQgZ3owID0gdmVjNCgwLjUpIC0gYWJzKGd4MCkgLSBhYnMoZ3kwKTtcXG4gIHZlYzQgc3owID0gc3RlcChnejAsIHZlYzQoMC4wKSk7XFxuICBneDAgLT0gc3owICogKHN0ZXAoMC4wLCBneDApIC0gMC41KTtcXG4gIGd5MCAtPSBzejAgKiAoc3RlcCgwLjAsIGd5MCkgLSAwLjUpO1xcblxcbiAgdmVjNCBneDEgPSBpeHkxICogKDEuMCAvIDcuMCk7XFxuICB2ZWM0IGd5MSA9IGZyYWN0KGZsb29yKGd4MSkgKiAoMS4wIC8gNy4wKSkgLSAwLjU7XFxuICBneDEgPSBmcmFjdChneDEpO1xcbiAgdmVjNCBnejEgPSB2ZWM0KDAuNSkgLSBhYnMoZ3gxKSAtIGFicyhneTEpO1xcbiAgdmVjNCBzejEgPSBzdGVwKGd6MSwgdmVjNCgwLjApKTtcXG4gIGd4MSAtPSBzejEgKiAoc3RlcCgwLjAsIGd4MSkgLSAwLjUpO1xcbiAgZ3kxIC09IHN6MSAqIChzdGVwKDAuMCwgZ3kxKSAtIDAuNSk7XFxuXFxuICB2ZWMzIGcwMDAgPSB2ZWMzKGd4MC54LGd5MC54LGd6MC54KTtcXG4gIHZlYzMgZzEwMCA9IHZlYzMoZ3gwLnksZ3kwLnksZ3owLnkpO1xcbiAgdmVjMyBnMDEwID0gdmVjMyhneDAueixneTAueixnejAueik7XFxuICB2ZWMzIGcxMTAgPSB2ZWMzKGd4MC53LGd5MC53LGd6MC53KTtcXG4gIHZlYzMgZzAwMSA9IHZlYzMoZ3gxLngsZ3kxLngsZ3oxLngpO1xcbiAgdmVjMyBnMTAxID0gdmVjMyhneDEueSxneTEueSxnejEueSk7XFxuICB2ZWMzIGcwMTEgPSB2ZWMzKGd4MS56LGd5MS56LGd6MS56KTtcXG4gIHZlYzMgZzExMSA9IHZlYzMoZ3gxLncsZ3kxLncsZ3oxLncpO1xcblxcbiAgdmVjNCBub3JtMCA9IHRheWxvckludlNxcnQodmVjNChkb3QoZzAwMCwgZzAwMCksIGRvdChnMDEwLCBnMDEwKSwgZG90KGcxMDAsIGcxMDApLCBkb3QoZzExMCwgZzExMCkpKTtcXG4gIGcwMDAgKj0gbm9ybTAueDtcXG4gIGcwMTAgKj0gbm9ybTAueTtcXG4gIGcxMDAgKj0gbm9ybTAuejtcXG4gIGcxMTAgKj0gbm9ybTAudztcXG4gIHZlYzQgbm9ybTEgPSB0YXlsb3JJbnZTcXJ0KHZlYzQoZG90KGcwMDEsIGcwMDEpLCBkb3QoZzAxMSwgZzAxMSksIGRvdChnMTAxLCBnMTAxKSwgZG90KGcxMTEsIGcxMTEpKSk7XFxuICBnMDAxICo9IG5vcm0xLng7XFxuICBnMDExICo9IG5vcm0xLnk7XFxuICBnMTAxICo9IG5vcm0xLno7XFxuICBnMTExICo9IG5vcm0xLnc7XFxuXFxuICBmbG9hdCBuMDAwID0gZG90KGcwMDAsIFBmMCk7XFxuICBmbG9hdCBuMTAwID0gZG90KGcxMDAsIHZlYzMoUGYxLngsIFBmMC55eikpO1xcbiAgZmxvYXQgbjAxMCA9IGRvdChnMDEwLCB2ZWMzKFBmMC54LCBQZjEueSwgUGYwLnopKTtcXG4gIGZsb2F0IG4xMTAgPSBkb3QoZzExMCwgdmVjMyhQZjEueHksIFBmMC56KSk7XFxuICBmbG9hdCBuMDAxID0gZG90KGcwMDEsIHZlYzMoUGYwLnh5LCBQZjEueikpO1xcbiAgZmxvYXQgbjEwMSA9IGRvdChnMTAxLCB2ZWMzKFBmMS54LCBQZjAueSwgUGYxLnopKTtcXG4gIGZsb2F0IG4wMTEgPSBkb3QoZzAxMSwgdmVjMyhQZjAueCwgUGYxLnl6KSk7XFxuICBmbG9hdCBuMTExID0gZG90KGcxMTEsIFBmMSk7XFxuXFxuICB2ZWMzIGZhZGVfeHl6ID0gZmFkZShQZjApO1xcbiAgdmVjNCBuX3ogPSBtaXgodmVjNChuMDAwLCBuMTAwLCBuMDEwLCBuMTEwKSwgdmVjNChuMDAxLCBuMTAxLCBuMDExLCBuMTExKSwgZmFkZV94eXoueik7XFxuICB2ZWMyIG5feXogPSBtaXgobl96Lnh5LCBuX3ouencsIGZhZGVfeHl6LnkpO1xcbiAgZmxvYXQgbl94eXogPSBtaXgobl95ei54LCBuX3l6LnksIGZhZGVfeHl6LngpOyBcXG4gIHJldHVybiAyLjIgKiBuX3h5ejtcXG59XFxuXFxudmFyeWluZyB2ZWMyIHZVdjtcXG52YXJ5aW5nIGZsb2F0IG5vaXNlO1xcbnZhcnlpbmcgZmxvYXQgbG93Tm9pc2U7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICB2ZWMzIENvbG9yVG9wID0gdmVjMygxLiwwLjU1LDApO1xcbiAgICB2ZWMzIENvbG9yTWlkID0gdmVjMygwLjIyNiwwLjAwMCwwLjYxNSk7XFxuICAgIHZlYzMgQ29sb3JCb3QgPSB2ZWMzKDAsMCwwKTtcXG4gICAgZmxvYXQgTWlkZGxlID0gMC44NTtcXG5cXG4gICAgZmxvYXQgayA9IDEuMC0gcG93KG5vaXNlLCAxLjQpO1xcbiAgICBmbG9hdCBrc3RlcCA9IHN0ZXAoaywgTWlkZGxlKTtcXG4gICAgXFxuICAgIHZlYzMgY29sb3IgPSBtaXgoXFxuICAgICAgICBDb2xvclRvcCxcXG4gICAgICAgIENvbG9yTWlkLFxcbiAgICAgICAgayAvIE1pZGRsZVxcbiAgICApICoga3N0ZXA7XFxuXFxuICAgIGNvbG9yICs9IG1peChcXG4gICAgICAgIENvbG9yTWlkLFxcbiAgICAgICAgQ29sb3JCb3QsXFxuICAgICAgICAoayAtIE1pZGRsZSkgLyAoMS4wIC0gTWlkZGxlKVxcbiAgICApICogKDEuMCAtIGtzdGVwKTtcXG5cXG4gICAgLy9jb2xvciA9IHZlYzMoIHBub2lzZSggdmVjMyggdlV2Lnh5ICogMTAuMCwgMSApLCB2ZWMzKCAxMC4wLCAxMC4wLCAxMC4wICkgKSApO1xcbiAgICAvL2NvbG9yID0gdmVjMyhhYnMobm9pc2UqMS4wKSk7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoIGNvbG9yLCAxLjAgKTtcXG5cXG59XCIiXSwic291cmNlUm9vdCI6IiJ9